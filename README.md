<h1>Type Driven Design Manifesto</h1>
<h2>Rule #0</h2>
<h3>Absolute Zero</h3>
<p>
No code = no issues. No sinks = no vulnerabilities. No user controlled input = no vector of attack.
</p>
<p>Based on that:</p>
<ul>
<li>always delete obsolete, dead, unreachable code.</li>
<li>do not ask user to provide more input than needed. In number of situations needed data can be generated by the system. e.g. name of the uploaded file</li>
<li>use least expressive language to talk to application</li>
</ul>
<h2>Rule #1</h2>
<h3>The Lord of the Sinks</h3>
<p>
Do context specific escaping on its boundary
</p>
<ul>
<li>escape data as close to the sink as possible.</li>
<li>escape any data regardless of its source, whether it's user provided or system generated.</li>
<li>extract raw value of ValueObject right before escaping</li>
</ul>
<h2>Rule #2</h2>
<h3>Least Power Principle</h3>
<p>Access to computational power is a privilege</p>
<ul>
<li>Parse (don't validate) input data as close to source as possible</li>
<li>Use Always valid ValueObjects (force invariants)</li>
<li>Do not transfer malicious data from source to sink</li>
</ul>
<h2>Rule #3</h2>
<h3>Forget-me-not</h3>
<p>Avoid shotgun parsing. Don't forget information regarding validity of a certain input, to not have to do validation again here and there or blindly assume that validation was done before.</p>
<ul>
<li>Do not use strings as ubiquitous data type for unstructured data</li>
<li>Declare custom types using ValueObjects to distinguish different kinds of data</li>
<li>Pass instances of custom types (ValueObjects) from source to sink</li>
<li>Use raw values of ValueObject only inside single context, always pass ValueObjects across the boundaries</li>
</ul>
